<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Search.ObjectStore.Bond4Client</name>
    </assembly>
    <members>
        <member name="T:Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration">
            <summary>
            Configuration of connection pool.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration.MaxConnectionsPerEnvironment">
            <summary>
            Maximum number of dedicated connections. If <c>null</c>, will be the same as MaxSimultaneousRequests.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration.KeepAliveIntervalMs">
            <summary>
            Keep alive interval for SLB connections
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration.Enable">
            <summary>
            When <c>null</c>, enable or disable the pool depending on whether PHX domain is accessible
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration.PreestablishConnections">
            <summary>
            Preestablish HTTP connections once it's clear that they will be required.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration">
            <summary>
            Configuration of connection pool.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.#ctor">
            <summary>
            Create a default configuration.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.#ctor(Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.MaxConnectionsPerEnvironment">
            <summary>
            Maximum number of dedicated connections. If <c>null</c>, will be the same as MaxSimultaneousRequests.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.KeepAliveIntervalMs">
            <summary>
            Keep alive interval for SLB connections
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.Enable">
            <summary>
            When <c>null</c>, enable or disable the pool depending on whether PHX domain is accessible
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration.PreestablishConnections">
            <summary>
            Preestablish HTTP connections once it's clear that they will be required.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ConnectionPool.ConnectionPair">
            <summary>
            Each connection is represented as a pair of connections: one through SLB, another is direct.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.ConnectionPair.HasDedicatedConnection">
            <summary>
            Checks if the dedicated connection has been created in this pair.
            </summary>
            <returns>True, if a dedicated connection has been created in this pair.</returns>
        </member>
        <member name="T:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool">
            <summary>
            Manages connections to a single environment
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.#ctor(Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration)">
            <summary>
            Creates a new connection pool
            </summary>
            <param name="config">Pool configuration</param>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.#ctor(Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration,Microsoft.Search.ObjectStore.Memory.IMemoryAllocator)">
            <summary>
            Creates a new connection pool
            </summary>
            <param name="config">Pool configuration</param>
            <param name="allocator">Memory allocator to be used by HTTP requests created by this pool</param>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.SendAsyncRequest(Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext)">
            <summary>
            A drop-in replacement for HttpAsyncInterface.SendAsyncRequest().
            </summary>
            <param name="context">Context containing information about the request</param>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.Callback(Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext,System.Net.HttpStatusCode,System.Exception,System.ArraySegment{System.Byte})">
            <summary>
            Called back when a request finishes
            </summary>
            <param name="httpRequestContext">The context of the request that is finished</param>
            <param name="returnCode">The return code from the Http request</param>
            <param name="configurationException">Any exception (such as DNS resolution problems or serialization errors) that occurred during the request</param>
            <param name="response">The response to the request</param>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.Dispose">
            <summary>
            IDisposable implementation
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.PoolLock">
            <summary>
            Guards operations on connection queues
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.SlbConnectionGroupId">
            <summary>
            Incremented each time we need a unique name to force a new connection through the SLB
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.DedicatedConnectionGroupId">
            <summary>
            Incremented each time we need a unique name to force a new dedicated connection
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.MaxConnections">
            <summary>
            Maximum total number of connections
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.KeepAliveInterval">
            <summary>
            The value of TCP KeepAlive property for SLB connections
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.PreestablishConnections">
            <summary>
            Preestablish HTTP connections once it's clear that they will be required.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.Enable">
            <summary>
            Create dedicated connections when true; pass requests through when false.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.NumRequestsThroughSlb">
            <summary>
            Number of requests sent through the SLB
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.NumDirectRequests">
            <summary>
            Number of requests sent through dedicated connections
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.ActiveConnections">
            <summary>
            Connections with outstanding requests. When reused, a connection with the fewest number of current requests is preferred.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ConnectionPool.EnvironmentConnectionPool.IdleConnections">
            <summary>
            Connections without outstanding requests. Are reused in a round-robin manner.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ConnectionPool.PriorityQueue`1">
            <summary>
            Not the most efficient implementation of priority queue
            </summary>
            <typeparam name="T">The type of values stored in the queue</typeparam>
        </member>
        <member name="M:Microsoft.ObjectStore.ConnectionPool.PriorityQueue`1.Peek">
            <summary>
            
            </summary>
            <returns>Iterator to an element with the highest priority</returns>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties">
            <summary>
            Settings for HTTP request
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.#ctor(System.String,System.Int32)">
            <summary>
            Properties of HTTP connection
            </summary>
            <param name="url"></param>
            <param name="timeoutInMs"></param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.Clone">
            <summary>
            
            </summary>
            <returns>A copy of the object</returns>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.Url">
            <summary>
            Request URL
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.Headers">
            <summary>
            HTTP headers
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.TimeoutInMs">
            <summary>
            Request timeout
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.ConnectionLimit">
            <summary>
            Maximum number of connections allowed on the ServicePoint object
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.ConnectionLeaseTimeout">
            <summary>
            The number of milliseconds after which the connection is closed.
            Default is -1 which allows the connection to stay open indefinitely.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.ConnectionGroupName">
            <summary>
            Name of the connection group for the request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.ClientCertificates">
            <summary>
            The collection of security certificates used as client certificates.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.ContentType">
            <summary>
            Value of Content-type HTTP header
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.EnableTcpKeepAlive">
            <summary>
            Enable keep-alive option on the TCP connection?
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.KeepAliveTime">
            <summary>
            Timeout, in milliseconds, with no activity until the first keep-alive packet is sent.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.KeepAliveInterval">
            <summary>
            Interval, in milliseconds, between when successive keep-alive packets are sent if no acknowledgement is received. 
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties.CertificateValidator">
            <summary>
            Certificate validator to be used for HTTPS requests.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.#ctor(Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties,Microsoft.ObjectStore.HTTPInterface.RequestFinishCallback,System.String,System.String,System.String,Microsoft.Search.ObjectStore.Memory.IMemoryAllocator,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Construct http request 
            </summary>
            <param name="connectionProperties">HTTP connection properties</param>
            <param name="callback">Callback to call when execution is finished</param>
            <param name="nameSpace">Namespace of the table on which the request acts</param>
            <param name="table">Name of the table on which the requests acts</param>
            <param name="operationName">Name of the operation being performed</param>
            <param name="allocator"></param>
            <param name="isDebugRequest">Is debug request or not</param>
            <param name="returnTimestamps">Need return timestamps or not</param>
            <param name="returnThrottlingInfo">Need return throttling info or not</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.Add(`0,`1)">
            <summary>
            Adds a key and a value to http server request.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.Add(`0)">
            <summary>
            Adds a key to http server request.
            </summary>
            <param name="key">The key</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.NumKeys">
            <summary>
            Returns the number of keys in the request container
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.SetRequestParam(`2)">
            <summary>
            Set request parameter
            </summary>
            <param name="param">Request parameter</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.SerializeRequest">
            <summary>
            Serialize http request information
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.requestObj">
            <summary>
            The request object which this container encapsulates
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.HTTPInterface.HttpRequestContext`4.serializationCache">
            <summary>
            Cached serialized version of the object used to avoid redoing serialization during request retries
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.HttpResponseContext`1">
            <summary>
            Wrapper around auto generated ObjectStore Response class
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpResponseContext`1.#ctor(System.ArraySegment{System.Byte})">
            <summary>
            Construct http response 
            </summary>
            <param name="response">HTTP response</param>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.HttpResponseContext`1.Responses">
            <summary>
            The SubResponses included in the response
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpResponseContext`1.ToString">
            <summary>
            Converts response to string form
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.HTTPInterface.HttpResponseContext`1.responseObj">
            <summary>
            The response object which this container encapsulates
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext">
            <summary>
            Encapsulates information about HTTP request.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.#ctor(Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties,Microsoft.ObjectStore.HTTPInterface.RequestFinishCallback)">
            <summary>
            Builds a context for sending an HTTP request to the server
            </summary>
            <param name="connectionProperties">HTTP connection properties</param>
            <param name="callback">Callback to call when execution is finished</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.#ctor(Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties,Microsoft.ObjectStore.HTTPInterface.RequestFinishCallback,Microsoft.Search.ObjectStore.Memory.IMemoryAllocator,System.Boolean)">
            <summary>
            Builds a context for sending an HTTP request to the server
            </summary>
            <param name="connectionProperties">HTTP connection properties</param>
            <param name="callback">Callback to call when execution is finished</param>
            <param name="allocator">Memory allocator to use to allocate memory dynamically (enables buffer pooling)</param>
            <param name="isDebugRequest">is debug flag set</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.SerializeRequest">
            <summary>
            Serialize http request information
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.DeserializeResponse(System.ArraySegment{System.Byte})">
            <summary>
            Specifies how to deserialize HTTP response for this request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.ConnectionProperties">
            <summary>
            HTTP connection properties
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.Callback">
            <summary>
            Callback to call when execution is finished
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.Allocator">
            <summary>
            Memory allocator that will be used for all dynamic allocations.
            Could be useful to enable buffer pooling to avoid LOH usage.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext.IsDebugRequest">
            <summary>
            Flag to indicate whether to collect request latency breakdown to ETW trace.
            The falg is set by WithDebugInfoEnabled
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.IHttpResponseContext">
            <summary>
            Represents HTTP response.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.IHttpResponseContext.GetProxyMachine">
            <summary>
            Extract proxy machine name from the response.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.RequestFinishCallback">
            <summary>
            Callback called when the request finishes
            </summary>
            <param name="context">The original context of the request</param>
            <param name="returnCode">The HttpStatusCode returned by the request (OK by default)</param>
            <param name="configurationException">Any exceptions that occurred during the execution of the request</param>
            <param name="response">HTTP Response</param>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface">
            <summary>
            Handle asynchronous request sending, timeouts and retries
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.SendAsyncRequest(Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext)">
            <summary>
            Method to send http web request to object store server
            </summary>
            <param name="context">Context containing information about the request</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.GetWebRequest(Microsoft.ObjectStore.HTTPInterface.HttpConnectionProperties)">
            <summary>
            Returns an HttpWebRequest for the given url
            </summary>
            <param name="connectionProperties">HTTP connection properties</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.TimeoutCallback(System.Object,System.Boolean)">
            <summary>
            Aborts an http request if it takes too long
            </summary>
            <param name="state">The AsyncRequestState object corresponding to the http request</param>
            <param name="timedOut">Indicates whether the request timed out</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.NotifyUser(Microsoft.ObjectStore.HTTPInterface.AsyncRequestState,System.Net.HttpStatusCode,System.Exception,System.ArraySegment{System.Byte})">
            <summary>
            Notifies the user that a request is finished by calling the request's callback
            </summary>
            <param name="state">The request state</param>
            <param name="httpStatus">HTTP status code. Ignored when <paramref name="configurationException" /> is present</param>
            <param name="configurationException">Exception thrown while executing the request</param>
            <param name="httpResponse">HTTP response</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.RequestStreamCallBack(System.IAsyncResult)">
            <summary>
            Handles BeginGetRequestStream callback for an http request
            </summary>
            <param name="result">Object containing context information</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.ResponseCallback(System.IAsyncResult)">
            <summary>
            Called when an http request completes
            </summary>
            <param name="result">Object containing context information</param>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.EnablePerformanceCounters">
            <summary>
            Setup performance counters on demand.
            Note: this is not thread safe.
            Throw if PerformanceCounter setup with exceptions 
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.TOO_MANY_REQUESTS_HTTP_STATUS_CODE">
            <summary>
            HTTP status code returned in response to throttled requests
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.IsStaticInitialized">
            <summary>
            Flag for static initialization
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.HTTPInterface.HttpAsyncInterface.Initialize">
            <summary>
            Method to trigger static initialization.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState">
            <summary>
            Stores temporary data for an async request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.Request">
            <summary>
            Http Web request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.Response">
            <summary>
            Http Web Response
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.TimeoutEvent">
            <summary>
            Event used for trigerring timeout action
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.CallbackCalled">
            <summary>
            Indicates whether the callback has been called
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.WaitHandle">
            <summary>
            Wait handle for this request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.HTTPInterface.AsyncRequestState.StopwatchTotal">
            <summary>
            Time measurement for performance counters
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataLoadConfiguration">
            <summary>
            Stores configuration information for loading data into ObjectStore using point updates
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoadConfiguration.#ctor(System.Collections.Generic.List{Microsoft.ObjectStore.ITableLocation},System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor initializing required and optional properties
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoadConfiguration.#ctor(System.Collections.Generic.List{Microsoft.ObjectStore.ITableLocation},System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>
            Constructor allowing to set advanced properties
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoadConfiguration.#ctor(System.Collections.Generic.List{Microsoft.ObjectStore.ITableLocation},System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            For backward binary compatibility
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.Locations">
            <summary>
            List of locations to which to send requests
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.NamespaceName">
            <summary>
            Name of the namespace of the table to which data is sent
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.TableName">
            <summary>
            Name of the table to which data is sent
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.MaxObjectsPerRequest">
            <summary>
            The maximum number of objects per single request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.MaxSimultaneousRequests">
            <summary>
            The maximum number of simultaneous HTTP requests alive at any time
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.RetriesPerRequest">
            <summary>
            The number of times each request is retried before marking it as failed
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.HttpTimeoutInMs">
            <summary>
            The maximum amount of time an HTTP request can be outstanding before it is aborted (in ms) 
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.HttpHeaders">
            <summary>
            HTTP headers to pass with each request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.MaxKeysPerSec">
            <summary>
            The maximum keys per second that the loader is allowed to send to a given location. Non-positive values mean unlimited keys per second.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.ReduceTrafficWhenThrottlingOccurs">
            <summary>
            Reduces the traffic to the store when traffic is throttled by ObjectStore. Requires MaxKeysPerSec to be set.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.ThrottlingMeasurementIntervalSec">
            <summary>
            Indicates the minimum duration of the period used to measure the throttling rate to the store 
            when ReduceTrafficWhenThrottlingOccurs is active. Internal use only.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.MinTrafficIncreaseIntervalSec">
            <summary>
            Indicates the minimum amount of time that has to pass without any throttled requests to increase
            the traffic to the store when ReduceTrafficWhenThrottlingOccurs is active. Internal use only.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.RespectServerThrottlingInfo">
            <summary>
            Wether respect throttling info returned by server.
            If set to true, client will adjust send rate according to server status.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.GetPartitionKeyCallback">
            <summary>
            Callback to return partition key for a key
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.AdjustPartitionKpsCallback">
            <summary>
            Customized logic for adjusting max kps for each partition.
            It is used only when RespectServerThrottlingInfo is set to true.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.MaxObjectsInQueuePerLocation">
            <summary>
            Maximum number of objects that can be kept in queue per environment.
            This parameter is used only when RespectServerThrottlingInfo=true.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.ConnectionPoolConfig">
            <summary>
            Configuration of connection pool. <c>null</c> to disable the pool.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.CopyObjects">
            <summary>
            Indicates whether the library should keep an internal copy of the objects passed to it or reuse the objects passed by the user.
            If the flag is set to false, the key and value should not be modified by the user after they are passed to the library 
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadConfiguration.UseDefaultCertificateValidator">
            <summary>
            Default certificate validator for HTTPS connections will check that root certificate issuer matches Autopilot.
            If you set this to <c>false</c>, you need to setup your own certificate validator as decribed at
            https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/HTTPS%20client%20guidelines.aspx
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataLoader">
            <summary>
            DataLoader allows uploading data to the same point table in multiple environments.
            It works in multiple threads, takes care of retries, controls QPS and adjusts writing rate
            if requests are throttled.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.#ctor(Microsoft.ObjectStore.DataLoadConfiguration)">
            <summary>
            Constructs an object for sending requests to a list of datacenter locations
            </summary>
            <param name="config">Configuration including locations to contact</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Send(System.Object,System.Object,System.Object)">
            <summary>
            Adds a write operation on a key/Value pair to a pending request. 
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="value">Object value</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Send(System.Object,System.Object,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean,System.Object)">
            <summary>
            Adds a write operation with the given timestamps on a key/Value pair to a pending request. 
            Writes with timestamps only allow 1 object per request, any pending requests will be sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="value">Object value</param>
            <param name="createTimestamp">The create timestamp to use, null means use default</param>
            <param name="updateTimestamp">The update timestamp to use, null means use default</param>
            <param name="updateOnlyIfNewer">If set to true and updateTimestamp is provided, the sent item will be written to ObjectStore only if its update timestamp is greater than the current update timestamp</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Read(System.Object,System.Object)">
            <summary>
            Adds a read operation to the pending request queue.
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
            <exception cref="T:System.InvalidOperationException">If table value type was not provided in configuration</exception>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Delete(System.Object,System.Object)">
            <summary>
            Adds a delete operation to the pending request queue.
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Flush">
            <summary>
            Sends the current pending request (if any).
            The method blocks until the request is sent if MaxSimultaneousRequests are already active.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Dispose">
            <summary>
            IDisposable implementation
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoader.Receive(System.Boolean)">
            <summary>
            Returns the results for operations that have been completed since the last call to Receive().
            </summary>
            <param name="waitForAllRequests">
            Indicates whether Receive() should block until all pending send requests are done
            </param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoader.config">
            <summary>
            Configuration for the loader
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoader.loaders">
            <summary>
            A list of DataLoaderImpls. There is on DataLoaderImpl per DC/Location.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.OperationType">
            <summary>
            Defines the type of an operation
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataItem">
            <summary>
            Container for a key/value pair and a context
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataLoaderImpl">
            <summary>
            DataLoaderImpl uploads data to one environment.
            It works in multiple threads, takes care of retries, controls QPS and adjusts writing rate
            if requests are throttled.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.#ctor(Microsoft.ObjectStore.ITableLocation,Microsoft.ObjectStore.DataLoadConfiguration)">
            <summary>
            Constructs an object for sending requests to a list of datacenter locations
            </summary>
            <param name="location">Target location of this data loader</param>
            <param name="config">Data loader configurations</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.AddDataItemAsync(Microsoft.ObjectStore.DataItem)">
            <summary>
            Adds an operation to the pending request queue.
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="item">Operation data item</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.FlushAsync(System.Boolean)">
            <summary>
            Sends the current pending request (if any).
            The method blocks until the request is sent if MaxSimultaneousRequests are already active.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.ReceiveAsync(System.Boolean)">
            <summary>
            Returns the results for operations that have been completed since the last call to Receive().
            </summary>
            <param name="waitForAllRequests">
            Indicates whether Receive() should block until all pending send requests are done
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.Dispose">
            <summary>
            IDisposable implementation
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.AddTimestampToHeaders(Microsoft.ObjectStore.DataLoaderRequestContext,System.String,System.Nullable{System.DateTime})">
            <summary>
            Adds a timestamp header to the request with the provided parameters
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.FlushItemsOfTypeAsync(Microsoft.ObjectStore.OperationType)">
            <summary>
            Flushes all items with the given operation type
            </summary>
            <param name="type">Type of the item to flush</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderImpl.Callback(Microsoft.ObjectStore.HTTPInterface.IHttpRequestContext,System.Net.HttpStatusCode,System.Exception,System.ArraySegment{System.Byte})">
            <summary>
            Called back when a request finishes
            </summary>
            <param name="httpRequestContext">The context of the request that is finished</param>
            <param name="returnCode">The return code from the Http request</param>
            <param name="configurationException">Any exception (such as DNS resolution problems or serialization errors) that ocurred during the request</param>
            <param name="responseBytes">The response to the request</param>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.FlushRetryIntervalInMs">
            <summary>
            Retry to flush queued requests in 100 ms
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.config">
            <summary>
            Configuration for the loader
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.location">
            <summary>
            Target location of this data loader
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.currentDataItems">
            <summary>
            Holds the data currently queued for sending
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.numDataItemsAddedSinceLastFlush">
            <summary>
            Number of data items receiveed since last flush
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.flushRetryDelayTime">
            <summary>
            Minimum time to wait before retrying flush
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.flushSemaphore">
            <summary>
            Semaphore used to enfored only one flush call at a time.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.requestSemaphore">
            <summary>
            Semaphore used to enforce config.MaxSimultaneousRequests
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.completedResults">
            <summary>
            Holds the set of completed results
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.lockCompletedResults">
            <summary>
            Lock object for completedResults
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.trafficManager">
            <summary>
            Traffic manager
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.numberOfPartitions">
            <summary>
            Total number of partitions of the table
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.partitionTrafficLimiters">
            <summary>
            Traffic limiter for each partition
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoaderImpl.disposed">
            <summary>
            Dispose flag
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderRequestContext.#ctor(Microsoft.ObjectStore.ITableLocation,System.Int32,Microsoft.ObjectStore.HTTPInterface.RequestFinishCallback,System.String,System.String,System.String,Microsoft.ObjectStore.OperationType,System.Boolean,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Builds a context for sending an HTTP request to the server
            </summary>
            <param name="location">The location to contact for this request</param>
            <param name="timeoutInMs">HTTP timeout</param>
            <param name="callback">Callback to call when execution is finished</param>
            <param name="nameSpace">Namespace of the table on which the request acts</param>
            <param name="table">Name of the table on which the requests acts</param>
            <param name="operationName">Name of the operation being performed</param>
            <param name="opType">The type of the operations in the request context</param>
            <param name="clientCertificates">Client certificates to use</param>
            <param name="returnThrottlingInfo">Need return throttling info or not</param>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoaderRequestContext.AddKey(ObjectStoreWireProtocol.BlobData,ObjectStoreWireProtocol.BlobData)">
            <summary>
            Adds a key and a value to http server request.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoaderRequestContext.RemainingRetries">
            <summary>
            Number of remaining retries
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoaderRequestContext.IsConditional">
            <summary>
            Indicates whether the operation is conditional/includes compare timestamp
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ReadResult">
            <summary>
            Stores information about Key read request using IDataLoader for a single location
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ReadResult.Location">
            <summary>
            Location from which the value was obtained
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ReadResult.DeserializeValue``1">
            <summary>
            Value from ObjectStore, or null if request succeeded but value was not found. Notice that this method performs deserialization of value, which
            means that a) multiple calls to it will return different instances of value, b) calling it twice means paying deserialization cost twice,
            c) any deserialization exception (for example, if you specify type incorrectly) will happen here
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataLoadResult">
            <summary>
            Stores information about a Key/Value pair write request using IDataLoader
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.DataLoadResult.AckLocation(Microsoft.ObjectStore.ILocationError,Microsoft.ObjectStore.IReadResult,System.Boolean)">
            <summary>
            Ack result for one location, and mark the result as failed if error happens on any location
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.Key">
            <summary>
            Key passed to IDataLoader.Send() when issuing the request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.Context">
            <summary>
            Context passed to IDataLoader.Send() when issuing the request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.IsSuccessful">
            <summary>
            Indicates whether the operation succeeded
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.ValueWasUpdated">
            <summary>
            Indicates whether the value was updated when using a conditional timestamp write
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.FailedLocations">
            <summary>
            A list containing a ILocationError for each location for which the request failed
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.DataLoadResult.ReadResults">
            <summary>
            A list containing read results for Read requests; null for Write and Delete requests
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.LocationError">
            <summary>
            Stores information about an error in the request to a particular location
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.LocationError.ToString">
            <summary>
            String representation of the error
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.LocationError.Location">
            <summary>
            The location for which the error applies
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.LocationError.ErrorType">
            <summary>
            The type of the error encountered
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.LocationError.HttpStatus">
            <summary>
            The http status code returned (OK by default)
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.LocationError.ObjectStoreCode">
            <summary>
            The ObjectStoreCode returned (UnknownResponseCode by default)
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.LocationError.RelatedConfigurationException">
            <summary>
            The exception that the IDataLoader encountered 
            while processing the request/response (null by default)
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.DataLoadResultSet">
            <summary>
            Holds the results from the requests sent to all locations for a particular list of data items
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoadResultSet.numRemainingResponses">
            <summary>
            The number of locations for which requests have not finished
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.DataLoadResultSet.results">
            <summary>
            The result data from the requests
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.Environment">
            <summary>
            Represents an AP environment, deprecated
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.Environment.URLSuffix">
            <summary>
            Suffix added to VIP URL generated from environment name
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.Environment.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs environment location object
            </summary>
            <param name="environmentName">The name of the AP environment</param>
            <param name="useBackendVIP">Flag to use backend VIP</param>
        </member>
        <member name="M:Microsoft.ObjectStore.Environment.GetUrl">
            <summary>
            Returns the URL ocation of the object store interface for the environment
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.Environment.ToString">
            <summary>
            Returns the name of the environment
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.Environment.Name">
            <summary>
            The name of the environment
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.Environment.environmentName">
            <summary>
            The name of the environemnt
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.IDataLoadConfiguration">
            <summary>
            Stores configuration information for loading data into ObjectStore using point updates
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.Locations">
            <summary>
            List of locations (such as environments/vips) to which to send requests
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.NamespaceName">
            <summary>
            Name of the namespace of the table to which data is sent
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.TableName">
            <summary>
            Name of the table to which data is sent
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.MaxObjectsPerRequest">
            <summary>
            The maximum number of objects per single request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.MaxSimultaneousRequests">
            <summary>
            The maximum number of simultaneous HTTP requests alive at any time
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.RetriesPerRequest">
            <summary>
            The number of times each request is retried before marking it as failed
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.HttpTimeoutInMs">
            <summary>
            The maximum amount of time an HTTP request can be outstanding before it is aborted (in ms) 
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.HttpHeaders">
            <summary>
            HTTP headers to pass with each request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.MaxKeysPerSec">
            <summary>
            The maximum keys per second that the loader is allowed to send to a given location. Non-positive values mean unlimited keys per second.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.ReduceTrafficWhenThrottlingOccurs">
            <summary>
            Reduces the traffic to the store when traffic is throttled by ObjectStore. Requires MaxKeysPerSec to be set to a positive value.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.ConnectionPoolConfig">
            <summary>
            Configuration of connection pool. <c>null</c> to disable the pool.
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.CopyObjects">
            <summary>
            Indicates whether the library should keep an internal copy of the objects passed to it or reuse the objects passed by the user.
            If the flag is set to false, the key and value should not be modified by the user after they are passed to the library 
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadConfiguration.UseDefaultCertificateValidator">
            <summary>
            Default certificate validator for HTTPS connections will check that root certificate issuer matches Autopilot.
            If you set this to <c>false</c>, you need to setup your own certificate validator as decribed at
            https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/HTTPS%20client%20guidelines.aspx
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ITableLocation">
            <summary>
            Represents a location to which ObjectStore http requests can be sent
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.ITableLocation.GetUrl">
            <summary>
            Returns the URL of ObjectStore interface for the location
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ITableLocation.Name">
            <summary>
            The name of the location
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.IDataLoader">
            <summary>
            DataLoader allows uploading data to the same point table in multiple environments.
            It works in multiple threads, takes care of retries, controls QPS and adjusts writing rate
            if requests are throttled.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Send(System.Object,System.Object,System.Object)">
            <summary>
            Adds a write operation on a key/Value pair to a pending request. 
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="value">Object value</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Send(System.Object,System.Object,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean,System.Object)">
            <summary>
            Adds a write operation with the given timestamps on a key/Value pair to a pending request. 
            Writes with timestamps only allow 1 object per request, any pending requests will be sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="value">Object value</param>
            <param name="createTimestamp">The create timestamp to use, null means use default</param>
            <param name="updateTimestamp">The update timestamp to use, null means use default</param>
            <param name="updateOnlyIfNewer">If set to true and updateTimestamp is provided, the sent item will be written to ObjectStore only if its update timestamp is greater than the current update timestamp</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Delete(System.Object,System.Object)">
            <summary>
            Adds a delete operation to the pending request queue.
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Read(System.Object,System.Object)">
            <summary>
            Adds a read operation to the pending request queue.
            If there are MaxObjectsPerRequest in the pending request, the request is sent.
            The method blocks until the request is sent if MaxSimultaneousRequests are already active or MaxKeysPerSec is reached.
            </summary>
            <param name="key">Object key</param>
            <param name="context">A context object passed with the result when Receive() is called</param>
            <exception cref="T:System.InvalidOperationException">If table value type was not provided in configuration</exception>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Flush">
            <summary>
            Sends the current pending request (if any).
            The method blocks until the request is sent if MaxSimultaneousRequests are already active.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.IDataLoader.Receive(System.Boolean)">
            <summary>
            Returns the results for operations that have been completed since the last call to Receive().
            </summary>
            <param name="waitForAllRequests">
            Indicates whether Receive() should block until all pending send requests are done
            </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ObjectStore.LocationErrorType">
            <summary>
            Error type for request failure to a location
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.LocationErrorType.HTTPStatusError">
            <summary>
            A bad HTTP code was returned by the server or request timed out
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.LocationErrorType.ObjectStoreError">
            <summary>
            ObjectStore returned an error
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.LocationErrorType.ConfigurationException">
            <summary>
            The DataLoader encountered an exception while preparing the request/response
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ObjectStoreReturnCode">
            <summary>
            Error code returned by Object Store
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ObjectStoreReturnCode.eFailure">
            <summary>
            Operation failed
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ObjectStoreReturnCode.eSuccessKeyPresent">
            <summary>
            Operation succeeded, key was present
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ObjectStoreReturnCode.eSuccessKeyNotPresent">
            <summary>
            Operation succeeded, key was not present
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.ObjectStoreReturnCode.eQueryStatusNewerRecordExists">
            <summary>
            A newer record exists, key was not updated
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.IReadResult">
            <summary>
            Stores information about Key read request using IDataLoader for a single location
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IReadResult.Location">
            <summary>
            Location from which the value was obtained
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.IReadResult.DeserializeValue``1">
            <summary>
            Value from ObjectStore, or null if request succeeded but value was not found. Notice that this method performs deserialization of value, which
            means that a) multiple calls to it will return different instances of value, b) calling it twice means paying deserialization cost twice,
            c) any deserialization exception (for example, if you specify type incorrectly) will happen here
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.IDataLoadResult">
            <summary>
            Stores information about a Key/Value pair write request using IDataLoader
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.Key">
            <summary>
            Key passed to IDataLoader.Send() when issuing the request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.Context">
            <summary>
            Context passed to IDataLoader.Send() when issuing the request
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.IsSuccessful">
            <summary>
            Indicates whether the operation succeeded
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.ValueWasUpdated">
            <summary>
            Indicates whether the value was updated when using a conditional timestamp write
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.FailedLocations">
            <summary>
            A list containing a ILocationError for each location for which the request failed
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.IDataLoadResult.ReadResults">
            <summary>
            A list containing read results for Read requests; null for Write and Delete requests
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.ILocationError">
            <summary>
            Stores information about an error in the request to a particular location
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ILocationError.Location">
            <summary>
            The location object for which the request failed
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ILocationError.ErrorType">
            <summary>
            The type of the error encountered
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ILocationError.HttpStatus">
            <summary>
            The http status code returned (OK by default)
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ILocationError.ObjectStoreCode">
            <summary>
            The ObjectStoreCode returned (UnknownResponseCode by default)
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.ILocationError.RelatedConfigurationException">
            <summary>
            The exception that the IDataLoader encountered 
            while processing the request/response (null by default)
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.maxAdjustmentMs">
            <summary>
            Maximum amount of time that is compensated by the manager
            because of oversleeping or lack of new requests.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32,Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration)">
            <summary>
            Builds a manegement object that controls QPS to a given location
            </summary>
            <param name="maxKeysPerSecond">Maximum keys per second. Non-positive number mean no restriction</param>
            <param name="enableThrottlingReduction">When enabled, traffic is reduced when throttling occurs</param>
            <param name="minTrafficIncreaseIntervalSec">Minimum amount of time that has to pass without throttling to increase traffic when enableThrottlingReduction is true</param>
            <param name="throttlingMeasurementIntervalSec">Minimum duration of time captured by each measurement of throttled traffic when enableThrottlingReduction is true</param>
            <param name="connectionPoolConfig">Configuration of connection pool (null to disable connection pool).</param>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.Start">
            <summary>
            Starts the sending thread
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.Stop">
            <summary>
            Stops the sending thread
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.QueueRequest(Microsoft.ObjectStore.DataLoaderRequestContext)">
            <summary>
            Queues request for sending.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.ReportRequestThrottled(System.Int64)">
            <summary>
            Reports to the manager that a request has been throttled.
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.BlockUntilNextRequestCanBeSent(System.Int32)">
            <summary>
            Notifies the rate limiting logic about a request and blocks execution until the request can be sent.
            </summary>
            <param name="numKeysInRequest">The number of keys in the request that will be sent</param>
        </member>
        <member name="M:Microsoft.ObjectStore.TrafficManager.AdjustLimits">
            <summary>
            Adjusts currentLimit based on recent information about throttled requests.
            If throttling is detected, we measure how much traffic is throttled in the next throttlingMeasurementIntervalSec
            and adjust the keys per second limit to 0.95 * amount of non-throttled traffic.
            We repeat the process until traffic is no longer throttled.
            When a random period between minTrafficIncreaseIntervalSec and minTrafficIncreaseIntervalSec*2 passes without any new throttled traffic
            we increase the traffic limit. The limit is increased based on a percentage of the maximum limit, where the percentage increases
            with each successful increase of the limit that does not lead to throttling.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.requestQueue">
            <summary>
            Queue of requests waiting to be sent
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.sendThreadEvent">
            <summary>
            Event signalled when the send thread needs to be woken up
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.maxLimit">
            <summary>
            The maximum rate (keys per second) that will be allowed by the traffic manager. Non-positive values are assumed to mean no limit.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.enableThrottlingReduction">
            <summary>
            When enable, reduces traffic when throttling is detected
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.currentLimit">
            <summary>
            The actual rate limit that is applied by the traffic manager
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.totalThrottledKeys">
            <summary>
            Total amount of keys sent by the manager that were throttled
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.totalKeys">
            <summary>
            Total amount of keys sent by the manager
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.lastSavedThrottledKeys">
            <summary>
            The value of totalThrottledKeys when the current measurement started
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.lastSavedTotalKeys">
            <summary>
            The value of totalKey when the current measurement started
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.lastSavedKeyTime">
            <summary>
            The time when the current measurement started
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.throttlingMeasurementIntervalSec">
            <summary>
            The minimum amount of time that each throttling measurement covers.
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.nextMeasurementStartTime">
            <summary>
            The time when the next measurement should start
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.minTrafficIncreaseIntervalSec">
            <summary>
            The minimum amount of time of throttling-free traffic that has to occur before a traffic increase occurs
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.nextTrafficIncreaseTime">
            <summary>
            The next time when the traffic will be increased assuming no throttling occurs
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.numConsecutiveTrafficIncreases">
            <summary>
            The number of times traffic has been successfully increased without any throttling occurring
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.random">
            <summary>
            Random number generator
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.running">
            <summary>
            Indicates whether the sending thread is running
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.sendingThread">
            <summary>
            The thread sending traffic requests
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.frequency">
            <summary>
            The frequency (ticks per second) returned by QueryPeformanceCounter
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.TrafficManager.nextRequestSendTime">
            <summary>
            The minimum time the next request should be sent
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.PartitionTrafficLimiter">
            <summary>
            PartitionTrafficLimiter limits number of keys that can sent to a partition in every second.
            It manages "credits" for sending requests to a partition  - to send a request, user need
            to obtain credit via AcquireCredit call first.
            Based on PartitionThrottlingInfo returned from server, it adjusts the the limit dynamically.
            </summary>
        </member>
        <member name="T:Microsoft.ObjectStore.VIP">
            <summary>
            Represents a VIP
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.VIP.URLSuffix">
            <summary>
            Suffix added to VIP URLs
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.VIP.Port">
            <summary>
            Port used by VIP URLs if none is specified
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.VIP.#ctor(System.String)">
            <summary>
            Constructs the vip
            </summary>
            <param name="vipURL">The name/url of the vip.
            To use https protocol, pass an https URL like "https://objectstoremulti.int.co.bing-int.com:443"
            and setup a certificate validation handler as described at 
            https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/HTTPS%20client%20guidelines.aspx
            </param>
        </member>
        <member name="M:Microsoft.ObjectStore.VIP.GetUrl">
            <summary>
            Returns the url of the object store interface
            </summary>
        </member>
        <member name="M:Microsoft.ObjectStore.VIP.ToString">
            <summary>
            Returns the name/url of the vip
            </summary>
        </member>
        <member name="P:Microsoft.ObjectStore.VIP.Name">
            <summary>
            The name/url of the vip
            </summary>
        </member>
        <member name="F:Microsoft.ObjectStore.VIP.vipURL">
            <summary>
            Url of the vip
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ClientInstrumentation">
            <summary>
            Holder for client performance instrumentation
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.HttpHeaders">
            <summary>
            Holder of http headers supported for objectstore request.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.Client.Builder``2(System.String,System.String,System.String,System.TimeSpan,System.Byte)">
            <summary>
            Initialize a builder for an ObjectStore client that connects to a single environment, namespace and store name.
            </summary>
            <typeparam name="TKey">Key type of ObjectStore table</typeparam>
            <typeparam name="TValue">Value type of ObjectStore table</typeparam>
            <param name="environment">
            The environment to query. This can use either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly.
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            See <a href="https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/AP%20Environments.aspx">this wiki page</a>
            for the full list of supported environments.
            Sample values of this parameter: ObjectStoreMulti.Prod.CO.BingInternal.com/sds, http://ObjectStoreMulti.Prod.CO.BingInternal.com/sds,
            https://ObjectStoreMulti.Prod.CO.BingInternal.com/sds
            </param>
            <param name="osNamespace">The name of the ObjectStore namespace.</param>
            <param name="osTable">The name of the ObjectStore table.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2">builder</see> for the client.
            Allows setting up additional options before creating the client.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.Client.CreateFakeClient``2">
            <summary>
            Create a fake ObjectStore client backed by an in-memory storage. Supports Read, Write and Delete operations.
            For more complex testing scenarios, mock IClient and request builder interfaces.
            </summary>
            <typeparam name="TKey">Key type of ObjectStore table</typeparam>
            <typeparam name="TValue">Value type of ObjectStore table</typeparam>
            <returns>A fake client</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.Client.EnablePerformanceCounters">
            <summary>
            Register for "ObjectStoreClient" Windows Performance Conters to add request latency breakdown samples to them. 
            Note: Turn this on may cause HttpAsyncInterface to spend sometime on counter setup which might take up to 10s.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithMemoryAllocator(Microsoft.Search.ObjectStore.Memory.IMemoryAllocator)">
            <summary>
            Setup a custom memory allocator to enable buffer pooling and avoid large object heap related issues.
            </summary>
            <param name="allocator">Custom implementation of <see cref="T:Microsoft.Search.ObjectStore.Memory.IMemoryAllocator"/></param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithConnectionPool(Microsoft.ObjectStore.ConnectionPool.IConnectionPoolConfiguration)">
            <summary>
            Use HTTP connection pool.
            </summary>
            Maintain a pool of direct connections to ObjectStore machines to avoid overloading the software load balancer.
            Available when the client is running in an Autopilot environment.
            <param name="poolConfig">Connection pool configuration; pass <code>null</code> to disable connection pool</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithCertificateValidator(System.Net.Security.RemoteCertificateValidationCallback)">
            <summary>
            Use custom certificate validation logic for HTTPS connections.
            As an example, see ValidateServerCertificate method at
            <a href="https://microsoft.sharepoint.com/teams/ObjectStoreWiki/_layouts/15/start.aspx#/SitePages/HTTPS%20client%20guidelines.aspx">HTTPS client guildelines</a>.
            </summary>
            <param name="certificateValidator">Validation callback</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithClientCertificates(System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Specify the collection of security certificates used as client certificates for HTTPS connections.
            </summary>
            <param name="certificates">A collection of security certificates</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithAccessTokenProvider(Microsoft.Search.ObjectStore.AccessToken.IAccessTokenProvider)">
            <summary>
            Specify an access token provider which issues object store access token.
            With a valid access token provider specified, an access token will be sent with every query.
            </summary>
            <param name="provider">ObjectStore access token provider</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithServicePointConnectionLimit(System.Int32)">
            <summary>
            Setup a custom connection limit on the underlying <see cref="T:System.Net.ServicePoint"/>.
            </summary>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithServicePointConnectionLeaseTimeout(System.Int32)">
            <summary>
            Setup a custom connection lease timeout on the underlying <see cref="T:System.Net.ServicePoint"/>.
            </summary>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.WithHttpClientHandler(System.Func{System.Net.Http.HttpClientHandler},System.Boolean)">
            <summary>
            Setup a custom factory for <see cref="T:System.Net.Http.HttpClientHandler"/>.
            </summary>
            <param name="httpClientHandlerFactory">
            Factory which provides new instance of <see cref="T:System.Net.Http.HttpClientHandler"/> for use in .net core compliant version of library.
            </param>
            <param name="disposeExternalHandler">
            Allows to keep ownership of allocated <see cref="T:System.Net.Http.HttpClientHandler"/> externally. If false and factory returns instance
             of the <see cref="T:System.Net.Http.HttpClientHandler"/>, it will not be disposed.
            </param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClientBuilder`2.Create">
            <summary>
            Create a client instance.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2"/></returns>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.IClient`2.DebugLog">
            <summary>
            Enables some additional logging, but possibly slows down the client
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.IClient`2.LogRequestsLongerThan">
            <summary>
            When <see cref="P:Microsoft.Search.ObjectStore.IClient`2.DebugLog"/> is set and a request takes longer than this time, log information about the request into event log.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Read(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepare a read request.
            </summary>
            <param name="keys">A sequence of keys to request</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IReadRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.ReadFromPrimary(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepare a readfromprimary request.
            This will guarantee no stale data is read but has a latency and availability penalty.
            </summary>
            <param name="keys">A sequence of keys to request</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IReadRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Write(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Prepare a write request.
            </summary>
            <param name="keysWithValues">A sequence of (key, value) pairs to write</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IWriteRequestBuilder">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.ContainsKeys(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepare a ContainsKeys request. Internally, this is ObjectStore Peek operation
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Delete(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepare a delete request.
            </summary>
            <param name="keys">A sequence of keys to delete</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IDeleteRequestBuilder">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Coproc``2(System.String,System.Collections.Generic.IEnumerable{`0},``1)">
            <summary>
            Prepare a coproc request.
            </summary>
            <typeparam name="TCoprocValue">The return type of the coproc</typeparam>
            <typeparam name="TRequestParam">The type of request parameter</typeparam>
            <param name="coprocName">Qualified name of the coproc to call (ServiceName.CoprocName)</param>
            <param name="keys">A sequence of keys to send to the coproc</param>
            <param name="requestParam">Request parameter</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Coproc``1(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepare a coproc request.
            </summary>
            <typeparam name="TCoprocValue">The return type of the coproc</typeparam>
            <param name="coprocName">Qualified name of the coproc to call (ServiceName.CoprocName)</param>
            <param name="keys">A sequence of keys to send to the coproc</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Coproc``3(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``1}},``2)">
            <summary>
            Prepare a coproc request.
            </summary>
            <typeparam name="TCoprocValue">The return type of the coproc</typeparam>
            <typeparam name="TKeyParam">The key parameter type of the coproc</typeparam>
            <typeparam name="TRequestParam">The type of request parameter</typeparam>
            <param name="coprocName">Qualified name of the coproc to call (ServiceName.CoprocName)</param>
            <param name="keysWithParams">A sequence of (key, key parameter) pairs to send to this coproc</param>
            <param name="requestParam">Request parameter</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.Coproc``2(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``1}})">
            <summary>
            Prepare a coproc request.
            </summary>
            <typeparam name="TCoprocValue">The return type of the coproc</typeparam>
            <typeparam name="TKeyParam">The key parameter type of the coproc</typeparam>
            <param name="coprocName">Qualified name of the coproc to call (ServiceName.CoprocName)</param>
            <param name="keysWithParams">A sequence of (key, key parameter) pairs to send to this coproc</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.IndexQuery(ObjectStoreWireProtocol.IndexQueryRequest)">
            <summary>
            Prepare an index query (OSearch) request
            </summary>
            <param name="indexQueryRequest">Request description</param>
            A <see cref="T:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2">builder</see> for the request. Allows setting up additional options before sending the request.
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.SparkPublish(ObjectStoreWireProtocol.SparkPublishRequest)">
            <summary>
            Prepare a spark publish request, to trigger spark publish job, ingest data from Mars into objectstore table
            </summary>
            <param name="sparkPublishRequest">Request description</param>
            A <see cref="T:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2">builder</see> for the request. Allows setting up additional options before sending the request.
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.SparkGetStatus(ObjectStoreWireProtocol.SparkPublishID)">
            <summary>
            Prepare a spark get status request, to get the running spark publish job status
            </summary>
            <param name="sparkPublishID">Request description</param>
            A <see cref="T:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2">builder</see> for the request. Allows setting up additional options before sending the request.
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.SparkKillJob(ObjectStoreWireProtocol.SparkPublishID)">
            <summary>
            Kill a running spark job
            </summary>
            <param name="sparkPublishID">Request description</param>
            A <see cref="T:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2">builder</see> for the request. Allows setting up additional options before sending the request.
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IClient`2.GetBulkDataDeploymentStatus(ObjectStoreWireProtocol.SparkPublishID,System.Collections.Generic.List{System.String},System.String,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Prepare a get bulk data deployment status
            </summary>
            <param name="sparkPublishID">bulk deployment request details</param>
            <param name="objectstoreEnvironments">environment urls to get deployment status from</param>
            <param name="dummyNamespaceName"></param>
            <param name="dummyTableName"></param>
            <param name="certificates"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder">
            <summary>
            Request builder to peek if request keys exit.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.WithTimestampsEnabled">
            <summary>
            Enable to return timestamps.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IContainsKeysRequestBuilder.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return list of values, in the same order as requested keys.
            If the key is not found, the corresponding value is <code>false</code>.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.WithTimestampsEnabled">
            <summary>
            Enable to return timestamps.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return a list of values and a list
            of debug information about each value, in the same order</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return list of values, in the same order as requested keys.
            If the key is not found, the corresponding value is <code>null</code>.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IReadRequestBuilder`1.SendAsyncWithoutRetries">
            <summary>
            Send the request asynchronously. Don't do retries and don't throw an exception if a key could not be queried due to an error.
            Instead, return a request status for each key.
            </summary>
            <returns>A task tracking this request. Will return the list of response results, in the same order as requested keys</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.WithTimestampsEnabled">
            <summary>
            Enable to return timestamps.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return a list
            of debug information about each write operation, in the same order</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IWriteRequestBuilder.SendAsyncWithoutRetries">
            <summary>
            Send the request asynchronously. Don't do retries and don't throw an exception if a key could not be written due to an error.
            Instead, return a request status for each key.
            </summary>
            <returns>A task tracking this request. Will return the list of response status, in the same order as requested keys</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.WithTimestampsEnabled">
            <summary>
            Enable to return timestamps.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return a list
            of debug information about each delete operation, in the same order</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IDeleteRequestBuilder.SendAsyncWithoutRetries">
            <summary>
            Send the request asynchronously. Don't do retries and don't throw an exception if a key could not be deleted due to an error.
            Instead, return a request status for each key.
            </summary>
            <returns>A task tracking this request. Will return the list of response status, in the same order as requested keys</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.WithBatchSize(System.Int32)">
            <summary>
            Divide the request in multiple batches.
            </summary>
            <param name="batchSize">Number of keys in one batch</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return a list of values returned by the coproc, in an arbitrary order</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ICoprocRequestBuilder`1.SendAsyncWithDetails">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>A task tracking this request. Will return a list of values returned by the coproc, in an arbitrary order and a list
            of debug information about each value, in the same order</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.WithInstrumentation(Microsoft.Search.ObjectStore.ClientInstrumentation)">
            <summary>
            Pass a ClientInstrumentation object to collect performance feedback.
            ToDo: Curretly, the latency measurement only collect from HTTPAsyncInterface which does not apply to Asp5 case
            </summary>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.GetKeysOnly">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the list of keys</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.GetKeysWithValues">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the list of OSearch results (with key, value and status)</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.GetKeysOnlyFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the full response of the key, including both individual document-level response and query-level response.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2.GetKeysWithValuesFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the detailed OSearch response</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the SparkPublishID for the spark job that needed later for get status</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.SendAsyncWithSparkPublishResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the SparkPublishResponse (with SparkPublishID, resultType and detailed error message)</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkRequestBuilder`2.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the full ObjectStoreResponse.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.SendAsync">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the SparkPublishResultType for the spark job</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.SendAsyncWithSparkPublishResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the SparkPublishResponse (with SparkPublishID, resultType and detailed error message)</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ISparkStatusBuilder`2.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the full ObjectStoreResponse.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IGetBulkDataDeploymentStatusBuilder`2.WithHttpHeaders(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Pass a collection of HTTP headers with the request.
            </summary>
            <param name="httpHeaders">HTTP headers</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IGetBulkDataDeploymentStatusBuilder`2.WithState(System.Object)">
            <summary>
            Set a state object that will be assigned as an <see cref="P:System.Threading.Tasks.Task.AsyncState"/> for this request's Task.
            </summary>
            <param name="state">State object</param>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IGetBulkDataDeploymentStatusBuilder`2.WithDebugInfoEnabled">
            <summary>
            Enable to return debug info for request processing.
            </summary>
            <returns>This builder, for fluent interface</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IGetBulkDataDeploymentStatusBuilder`2.SendAsyncWithSparkPublishResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the SparkPublishResponse (with SparkPublishID, resultType and detailed error message)</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IGetBulkDataDeploymentStatusBuilder`2.SendAsyncWithDebugFullResponse">
            <summary>
            Send the request asynchronously.
            </summary>
            <returns>The task tracking this request. Will return the full ObjectStoreResponse.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientExt.Read``2(Microsoft.Search.ObjectStore.IClient{``0,``1},``0)">
            <summary>
            Prepare a read request.
            </summary>
            <param name="client">An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2">client</see></param>
            <param name="key">The key to request</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IReadRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientExt.ReadFromPrimary``2(Microsoft.Search.ObjectStore.IClient{``0,``1},``0)">
            <summary>
            Prepare a readfromprimary request.
            This will guarantee no stale data is read but has a latency and availability penalty.
            </summary>
            <param name="client">An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2">client</see></param>
            <param name="key">The key to request</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IReadRequestBuilder`1">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientExt.Write``2(Microsoft.Search.ObjectStore.IClient{``0,``1},``0,``1)">
            <summary>
            Prepare a write request.
            </summary>
            <param name="client">An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2">client</see></param>
            <param name="key">The key to write</param>
            <param name="value">The value to write</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IWriteRequestBuilder">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientExt.Delete``2(Microsoft.Search.ObjectStore.IClient{``0,``1},``0)">
            <summary>
            Prepare a delete request.
            </summary>
            <param name="client">An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2">client</see></param>
            <param name="key">The key to delete</param>
            <returns>
            A <see cref="T:Microsoft.Search.ObjectStore.IDeleteRequestBuilder">builder</see> for the request. Allows setting up additional options before sending the request.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientExt.IndexQuery``2(Microsoft.Search.ObjectStore.IClient{``0,``1},System.String,System.UInt32,System.UInt32)">
            <summary>
            Prepare an index query (OSearch) request
            </summary>
            <param name="client">An instance of <see cref="T:Microsoft.Search.ObjectStore.IClient`2">client</see></param>
            <param name="query">Index query, in TLA syntax</param>
            <param name="resultBase">Result base, that is, 0-based page number of the results</param>
            <param name="resultCount">Total number of results to return</param>
            A <see cref="T:Microsoft.Search.ObjectStore.IIndexRequestBuilder`2">builder</see> for the request. Allows setting up additional options before sending the request.
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ClientParts.BondUtils.DeserializeKey``1(System.ArraySegment{System.Byte},Bond.SchemaDef)">
            <summary>
            Deserialize key bond blob using simple protocol.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <param name="keyBondBlob">Key bond blob</param>
            <param name="keyRuntimeSchema">Key runtime schema</param>
            <returns>Key value</returns>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2">
            <summary>
            Client for interacting with Object Store
            </summary>
            <typeparam name="TKey">The bond type for the key stored in the store.</typeparam>
            <typeparam name="TValue">The bond type for the value stored in the store.</typeparam>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocInput">
            <summary>
            Enumeration for different possible types for the input to a coproc
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocInput.Keys">
            <summary>
            IEnumerable{TKey}
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocInput.KeysWithKeyParams">
            <summary>
            IEnumerable{KeyValuePair{TKey, TKeyParam}}
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3">
            <summary>
            struct contains all parameters needed for a single coproc invocation request
            </summary>
            <typeparam name="TKeyParam">Parameter type for key parameters to be used by coprocs</typeparam>
            <typeparam name="TPar">Generics Parameter Type used by coproc</typeparam>
            <typeparam name="TResponse">Response type for the request (will return an ienumerable of this type)</typeparam>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3.Keys">
            <summary>
            The KeyDatas for Coproc operation. This property is used when a coproc is invoked with only key
            arguments, or when it is invoked with key arguments and a request parameter. This property is
            set to null when a coproc request that uses key parameters is created.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3.KeysWithKeyParams">
            <summary>
            The KeyDatas and their corresponding parameters for Coproc operation. This property is used when
            a coproc is invoked with a key parameter for each key argument. It is set to null when a coproc
            request that doesn't use key parameters is created.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3.CoprocName">
            <summary>
            Coproc operation name
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3.Parameter">
            <summary>
            The Request Parameter used by a coproc.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.CoprocRequest`3.InputType">
            <summary>
            Indiciation of which input is encapsulated in this request.
            This is used later to invoke the correct serialization method for the call.
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.connectionLeaseTimeout">
            <summary>
            Holds service point configurations if they are other than default.
            Note: We save these values because we found that servicePoint object
            will be collected regardless what MaxIdle value we use.
            Need to reset these value if the servicePoint Object get collected.
            http://bung2/#/DevDiv/search/table?q=CID%3DDevDiv.931965
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.DebugLog">
            <summary>
            Enables some additional logging, but possibly slows down the client
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.LogRequestsLongerThan">
            <summary>
            When <see cref="P:Microsoft.Search.ObjectStore.ClientParts.ClientImplBase`2.DebugLog"/> is set and a request takes longer than this time, log information about the request into event log.
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ClientParts.IBondValue`1">
            <summary>
            Abstracts away differences in interfaces for cloning and (de)serialization between Bond 3 and Bond 4.
            In addition, using this wrapper everywhere instead of raw Bond structures ensures that serializer/deserializer for each type are created only once.
            </summary>
            <typeparam name="TValue">Bond type wrapped in this interface</typeparam>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ObjectStoreStatus.Failed">
            <summary>
            Operation failed.
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ObjectStoreStatus.Succeded">
            <summary>
            Operation succeeded.
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ObjectStoreStatus.KeyNotFound">
            <summary>
            Requested key doesn't exist
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ObjectStoreStatus.NewerRecordExists">
            <summary>
            TODO
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ObjectStoreResult`1">
            <summary>
            Represents a result of a single key request.
            </summary>
            <typeparam name="TValue">Result type</typeparam>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ObjectStoreResult`1.Status">
            <summary>
            Request status
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ObjectStoreResult`1.Value">
            <summary>
            Request result
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.OSearchResult`2">
            <summary>
            OSearch result including, key, value and value status.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResult`2.#ctor(`0,`1,ObjectStoreWireProtocol.ObjectStoreQueryStatus)">
            <summary>
            Constructor.
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <param name="valueStatus">Value status, indicating sucess or any error</param>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResult`2.Key">
            <summary>
            Key.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResult`2.Value">
            <summary>
            Value.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResult`2.ValueStatus">
            <summary>
            Status of value response.
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.OSearchResultWithDetail`2">
            <summary>
            OSearch result with response details for both key and value.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResultWithDetail`2.#ctor(`0,`1,ObjectStoreWireProtocol.ObjectStoreQueryStatus,ObjectStoreWireProtocol.DebugIndexResponseInfo,ObjectStoreWireProtocol.ResultDetail)">
            <summary>
            Constructor.
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <param name="valueStatus">Value status</param>
            <param name="invertedIndexResultDetail">Result details of inverted index</param>
            <param name="valueResultDetail">Result details of value</param>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResultWithDetail`2.InvertedIndexResultDetail">
            <summary>
            Result detail of inverted index.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResultWithDetail`2.ValueResultDetail">
            <summary>
            Result detail  of value fetching.
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.OSearchResultWithDetail`1">
            <summary>
             OSearch result with response details for key only.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResultWithDetail`1.#ctor(`0,ObjectStoreWireProtocol.DebugIndexResponseInfo)">
            <summary>
            Constructor
            </summary>
            <param name="key">Key</param>
            <param name="invertedIndexResultDetail">Result details of inverted index</param>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.OSearchResponse`2">
            <summary>
            OSearch response which contains details of both individual document-level response and query-level response.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResponse`2.#ctor">
            <summary>
            Creating an empty response.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResponse`2.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Search.ObjectStore.OSearchResultWithDetail{`0,`1}},ObjectStoreWireProtocol.IndexResponse)">
            <summary>
            Constructor.
            </summary>
            <param name="resultList">Result list</param>
            <param name="responseDetail">Inverted index response detail</param>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResponse`2.ResultList">
            <summary>
            Per document responses.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.OSearchResponse`2.ResponseDetail">
            <summary>
            Query level responses.
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.OSearchResponse`1">
            <summary>
            Full response of index query key only, which contains both individual document-level response and query-level response.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResponse`1.#ctor">
            <summary>
            Create an empty object.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.OSearchResponse`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Search.ObjectStore.OSearchResultWithDetail{`0}},ObjectStoreWireProtocol.IndexResponse)">
            <summary>
            Constructor.
            </summary>
            <param name="resultList">Result list</param>
            <param name="responseDetail">Inverted index response detail</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.AccessToken.OSAccessTokenProvider.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean)">
            <summary>
            Create an instance of OSAccessTokenProvider class which issues object store access token.
            </summary>
            <param name="authority">Url of authority that issues object store access token.
            It could be either an IP address or a host name. Protocol (http or https) is optional, and only https is allowed.
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1/AccessToken" will be appended immediately after this value.
            See <a href="https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/AP%20Environments.aspx">this wiki page</a>
            for the full list of supported environments.
            Sample values of this parameter: ObjectStoreMulti.Prod.CO.BingInternal.com/sds, https://ObjectStoreMulti.Prod.CO.BingInternal.com/sds
            </param>
            <param name="clientCertificate">Client certificate</param>
            <param name="forGeoReplService">A flag indicating whether the issued object store access token  will be used to talk to a GeoRepl service.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.AccessToken.OSAccessTokenProvider.#ctor(System.String,System.Boolean,System.Func{System.Net.Http.HttpClientHandler},System.Boolean)">
            <summary>
            Create an instance of OSAccessTokenProvider class which issues object store access token.
            </summary>
            <param name="authority">Url of authority that issues object store access token.
            It could be either an IP address or a host name. Protocol (http or https) is optional, and only https is allowed.
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1/AccessToken" will be appended immediately after this value.
            See <a href="https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/AP%20Environments.aspx">this wiki page</a>
            for the full list of supported environments.
            Sample values of this parameter: ObjectStoreMulti.Prod.CO.BingInternal.com/sds, https://ObjectStoreMulti.Prod.CO.BingInternal.com/sds
            </param>
            <param name="forGeoReplService">A flag indicating whether the issued object store access token  will be used to talk to a GeoRepl service.</param>
            <param name="httpClientHandlerFactory">
            Factory which provides new instance of <see cref="T:System.Net.Http.HttpClientHandler"/> for use in .net core compliant version of library.
            httpClientHandlerFactory must return <see cref="T:System.Net.Http.HttpClientHandler"/> which should provide client certificate
            </param>
            <param name="disposeExternalHandler">
            Allows to keep ownership of allocated <see cref="T:System.Net.Http.HttpClientHandler"/> externally. If false and factory returns instance
             of the <see cref="T:System.Net.Http.HttpClientHandler"/>, it will not be disposed.
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.AccessToken.OSAccessTokenProvider.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32,System.Int32)">
            <summary>
            Create an instance of OSAccessTokenProvider class which issues object store access token.
            </summary>
            <param name="authority">Url of authority that issues object store access token.</param>
            <param name="clientCertificate">Client certificate</param>
            <param name="tokenTTLInSeconds">Token expiration period in seconds</param>
            <param name="cacheExpirationInSeconds">How long a token will be cached and reused</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.AccessToken.OSAccessTokenProvider.#ctor(System.String,System.Int32,System.Int32,System.Func{System.Net.Http.HttpClientHandler},System.Boolean)">
            <summary>
            Create an instance of OSAccessTokenProvider class which issues object store access token.
            </summary>
            <param name="authority">Url of authority that issues object store access token.</param>
            <param name="tokenTTLInSeconds">Token expiration period in seconds</param>
            <param name="cacheExpirationInSeconds">How long a token will be cached and reused</param>
            <param name="httpClientHandlerFactory">
            Factory which provides new instance of <see cref="T:System.Net.Http.HttpClientHandler"/> for use in .net core compliant version of library.
            httpClientHandlerFactory must return <see cref="T:System.Net.Http.HttpClientHandler"/> which should provide client certificate
            </param>
            <param name="disposeExternalHandler">
            Allows to keep ownership of allocated <see cref="T:System.Net.Http.HttpClientHandler"/> externally. If false and factory returns instance
             of the <see cref="T:System.Net.Http.HttpClientHandler"/>, it will not be disposed.
            </param>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.BadResponseException">
            <summary>
            Used to signal that a received response from Object Store is incomplete or malformatted.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.BadResponseException.#ctor(System.String)">
            <summary>
            Creates a new exception object.
            </summary>
            <param name="message">The message that the exception will contain.</param>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ObjectStoreTestHelper">
            <summary>
            Allows enabling or disabling test mode.
            </summary>
        </member>
        <member name="F:Microsoft.Search.ObjectStore.ObjectStoreTestHelper.testMode">
            <summary>
            This boolean determines whether the ObjectStore client
            operates in test mode or not. In test mode, it uses the
            Dictionary based ObjectStore implementation instead of making
            http calls to the ObjectStore.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreTestHelper.SetTestMode">
            <summary>
            Set test mode
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreTestHelper.UnsetTestMode">
            <summary>
            Unset test mode
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreTestHelper.IsTestMode">
            <summary>
            Check if test mode is on
            </summary>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ObjectStoreTestHelper`2">
            <summary>
            Class to mock ObjectStore behavior
            using a ConcurrentDictionary class underneath
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreTestHelper`2.GetClient(System.String,System.String,System.String)">
            <summary>
            Get an mock (in-memory) instance of IClient.
            </summary>
            <param name="environment"></param>
            <param name="osNamespace"></param>
            <param name="storeName"></param>
            <returns>IClient</returns>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.IObjectStoreClient`2">
            <summary>
            <para>Deprecated. Use <see cref="T:Microsoft.Search.ObjectStore.Client">Microsoft.Search.ObjectStore.Client</see> instead.</para>
            Interface for clients interacting with Object Store
            </summary>
            <typeparam name="TKey">The bond type for the key stored in the store.</typeparam>
            <typeparam name="TValue">The bond type for the value stored in the store.</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClient`2.UpdateAsync(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Object)">
            <summary>
            Updates the values stored for a set of keys.
            This overload should be used to reduce the cost of updating for several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keyValuePairs">The keys and the corresponding values to update.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClient`2.DeleteAsync(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Deletes keys along with their stored values from the store.
            This overload should be used to reduce the cost of deleting several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keys">The keys to delete.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClient`2.GetAsync(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Retrieves the values stored for a set of keys.
            This overload should be used to reduce the cost of querying for several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keys">The keys to query for.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            Keys that don't have values are present in the dictionary with a <c>null</c> value.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.IObjectStoreClient`2.DoQueryAsync``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``0}},System.String,``1,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Sends a coproc request.
            </summary>
            <typeparam name="TKeyParameter">Parameter type for key parameters to be used by coprocs</typeparam>
            <typeparam name="TRequestParameter">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keysWithKeyParams">The KeyDatas and their corresponding parameters for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="headers">Http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> resulted by coproc </returns>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2">
            <summary>
            Multicast version of <see cref="T:Microsoft.Search.ObjectStore.ObjectStoreClient`2"/> for write operations.
            Note that this client does not perform network level multicasting. It simply sends the same requests to multiple object store destinations at the same time.
            For read operations use <see cref="T:Microsoft.Search.ObjectStore.ObjectStoreClient`2"/> directly.
            The request for each destination is retried independently of the other destinations (each one can fail on its own without affecting the others).
            In order to establish success or failure on the aggregate level, consult the results and/or status of each returned <see cref="T:System.Threading.Tasks.Task"/>
            and apply your desired aggregation policy for success/failure.
            </summary>
            <typeparam name="TKey">The bond type for the key stored in the store.</typeparam>
            <typeparam name="TValue">The bond type for the value stored in the store.</typeparam>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination">
            <summary>
            Represents an Object Store destination.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.Environment">
            <summary>
            Gets the environment. This can be either an IP address or a host name.
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.Namespace">
            <summary>
            Gets the namespace for the store.
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.StoreName">
            <summary>
            Gets the name of the store.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Object Store destination.
            </summary>
            <param name="environment">
            The environment. This can be either an IP address or a host name.
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.ToString">
            <summary>
            Provides a compact string presentation of an Object Store destination
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Search.ObjectStore.MultiCastObjectStoreClient{`0,`1}.ObjectStoreDestination},System.TimeSpan,System.Byte)">
            <summary>
            Creates a new <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2"/> based on multiple <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination"/>s.
            </summary>
            <param name="destinations">The destinations that will be used for all write operations.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries for each destination when errors are encountered before returning the failure to the caller.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Search.ObjectStore.MultiCastObjectStoreClient{`0,`1}.ObjectStoreDestination},System.TimeSpan,System.Byte,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2"/> based on multiple <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination"/>s.
            </summary>
            <param name="destinations">The destinations that will be used for all write operations.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries for each destination when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.TimeSpan,System.Byte)">
            <summary>
            This overload allows easier creation of a <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2"/> in which all destinations share the same namespace and store name.
            </summary>
            <param name="destinationEnvironments">The <see cref="P:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.Environment"/> part of each destination to use.</param>
            <param name="osNamespace">The namespace to use for all destinations.</param>
            <param name="storeName">The store name to use for all destinations.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries for each destination when errors are encountered before returning the failure to the caller.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32)">
            <summary>
            This overload allows easier creation of a <see cref="T:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2"/> in which all destinations share the same namespace and store name.
            </summary>
            <param name="destinationEnvironments">The <see cref="P:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.ObjectStoreDestination.Environment"/> part of each destination to use.</param>
            <param name="osNamespace">The namespace to use for all destinations.</param>
            <param name="storeName">The store name to use for all destinations.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries for each destination when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.UpdateAsync(`0,`1,System.Object)">
            <summary>
            Updates the value for the specified key.
            If the key is not in the store, then it is added with the provided <paramref name="value"/>.
            </summary>
            <param name="key">The key to set</param>
            <param name="value">The value to store</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/> objects</param>
            <returns>
            A collection of <see cref="T:System.Threading.Tasks.Task"/>s that can be used to handle the update response either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>. The key for the dictionary is the string representation of the destination to which the <see cref="T:System.Threading.Tasks.Task"/>
            corresponds to.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.UpdateAsync(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Object)">
            <summary>
            Updates the values for the specified keys.
            </summary>
            <param name="kvp">The key value pair to set</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/> objects</param>
            <returns>
            A collection of <see cref="T:System.Threading.Tasks.Task"/>s that can be used to handle the update response either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>. The key for the dictionary is the string representation of the destination to which the <see cref="T:System.Threading.Tasks.Task"/>
            corresponds to.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.DeleteAsync(`0,System.Object)">
            <summary>
            Deletes a key along with its stored value from the store.
            If the key did not exist then the operation still succeeds.
            </summary>
            <param name="key">The key to delete</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/> objects</param>
            <returns>
            A collection of <see cref="T:System.Threading.Tasks.Task"/>s that can be used to handle the delete response either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>. The key for the dictionary is the string representation of the destination to which the <see cref="T:System.Threading.Tasks.Task"/>
            corresponds to.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.MultiCastObjectStoreClient`2.DeleteAsync(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Deletes the keys along with their stored values from the store.
            If a key did not exist then the operation still succeeds.
            </summary>
            <param name="keys">The keys to delete</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/> objects</param>
            <returns>
            A collection of <see cref="T:System.Threading.Tasks.Task"/>s that can be used to handle the delete response either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>. The key for the dictionary is the string representation of the destination to which the <see cref="T:System.Threading.Tasks.Task"/>
            corresponds to.
            </returns>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ObjectStoreClient`1">
            <summary>
            <para>Deprecated. Use <see cref="T:Microsoft.Search.ObjectStore.Client">Microsoft.Search.ObjectStore.Client</see> instead.</para>
            ObjectStoreClient which subclasses the ObjectStoreClient (TKey, TVal)
            with (TKey, BondVoid).
            
            This is done as there are several cases where the client doesn't care
            about the type of the valye (TVal) in the key value store.
            </summary>
            <typeparam name="TKey">The type for the key. IBondSerializable.</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`1.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte)">
            <summary>
            A constructor to match the parent constructor.
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`1.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32)">
            <summary>
            A constructor to match the parent constructor.
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`1.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32,Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration)">
            <summary>
            A constructor to match the parent constructor.
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
            <param name="connectionPoolConfig">Configuration of connection pool</param>
        </member>
        <member name="T:Microsoft.Search.ObjectStore.ObjectStoreClient`2">
            <summary>
            <para>Deprecated. Use <see cref="T:Microsoft.Search.ObjectStore.Client">Microsoft.Search.ObjectStore.Client</see> instead.</para>
            Client for interacting with Object Store
            </summary>
            <typeparam name="TKey">The bond type for the key stored in the store.</typeparam>
            <typeparam name="TValue">The bond type for the value stored in the store.</typeparam>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,Microsoft.Search.ObjectStore.Memory.IMemoryAllocator)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="allocator">Custom implementation of <see cref="T:Microsoft.Search.ObjectStore.Memory.IMemoryAllocator"/>. Use this to enable buffer pooling and avoid large object heep related issues</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32,Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
            <param name="connectionPoolConfig">Configuration of connection pool</param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32,Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration,System.Boolean)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
            <param name="connectionPoolConfig">Configuration of connection pool</param>
            <param name="useDefaultCertificateValidator">
            Default certificate validator for HTTPS connections will check that root certificate issuer matches Autopilot.
            If you set this to <c>false</c>, you need to setup your own certificate validator as decribed at
            https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/HTTPS%20client%20guidelines.aspx
            </param>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.#ctor(System.String,System.String,System.String,System.TimeSpan,System.Byte,System.Int32,System.Int32,Microsoft.ObjectStore.ConnectionPool.ConnectionPoolConfiguration,System.Boolean,Microsoft.Search.ObjectStore.Memory.IMemoryAllocator)">
            <summary>
            Creates a new Object Store client that connects to a single environment, namespace and store name
            </summary>
            <param name="environment">
            The environment to query. This can be either an IP address or a host name.
            Protocol (http or https) is optional. Be default HTTP is used. To use HTTPS, specify it explicitly
            You can also specify subpaths ("/sds" is usually needed if not using a onebox Object Store).
            "/ObjectStoreQuery/V1" will be appended immediately after this value.
            </param>
            <param name="osNamespace">The namespace for the store.</param>
            <param name="storeName">The name of the store.</param>
            <param name="timeout">The timeout to use for all operations.</param>
            <param name="maxRetries">The maximum number of retries when errors are encountered before returning the failure to the caller.</param>
            <param name="connectionLeaseTimeoutMs">
            The <see cref="P:System.Net.ServicePoint.ConnectionLeaseTimeout"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port). Default value is -1, meaning no timeout.
            This can be used in some situations to improve load distribution but still reuse HTTP connections.
            </param>
            <param name="connectionLimit">
            The <see cref="P:System.Net.ServicePoint.ConnectionLimit"/> to set for the <see cref="T:System.Net.ServicePoint"/>
            that will be used for the requests sent using all Object Store clients that have the same environment (hostname and port).
            This controls the maximum number of active HTTP connections to Object Store servers (all of them, not for each as they share the same hostname).
            </param>
            <param name="connectionPoolConfig">Configuration of connection pool</param>
            <param name="useDefaultCertificateValidator">
            Default certificate validator for HTTPS connections will check that root certificate issuer matches Autopilot.
            If you set this to <c>false</c>, you need to setup your own certificate validator as decribed at
            https://microsoft.sharepoint.com/teams/ObjectStoreWiki/SitePages/HTTPS%20client%20guidelines.aspx
            </param>
            <param name="allocator">Custom implementation of <see cref="T:Microsoft.Search.ObjectStore.Memory.IMemoryAllocator"/>. Use this to enable buffer pooling and avoid large object heep related issues</param>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DebugLog">
            <summary>
            Enables some additional logging, but possibly slows down the client
            </summary>
        </member>
        <member name="P:Microsoft.Search.ObjectStore.ObjectStoreClient`2.LogRequestsLongerThan">
            <summary>
            When <see cref="P:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DebugLog"/> is set and a request takes longer than this time, log information about the request into event log.
            </summary>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.Query(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Query the store for the given keys.
            </summary>
            <param name="keys">enumeration of keys to query</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <returns>The Task which returns the IEnumerable <see cref="T:Microsoft.Search.ObjectStore.ObjectStoreResult`1"/> which contains the response along with an enum indicating status</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.UpdateAsync(`0,`1,System.Object)">
            <summary>
            Updates the value for the specified key.
            If the key is not in the store, then it is added with the provided <paramref name="value"/>.
            </summary>
            <param name="key">The key to set</param>
            <param name="value">The value to store</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that can be used to complete the update either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.UpdateAsync(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Object)">
            <summary>
            Updates the values stored for a set of keys.
            This overload should be used to reduce the cost of updating for several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keyValuePairs">The keys and the corresponding values to update.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DeleteAsync(`0,System.Object)">
            <summary>
            Deletes a key along with its stored value from the store.
            If the key did not exist then the operation still succeeds.
            </summary>
            <param name="key">The key to delete</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that can be used to complete the delete either synchronously (<see cref="M:System.Threading.Tasks.Task.Wait"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DeleteAsync(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Deletes keys along with their stored values from the store.
            This overload should be used to reduce the cost of deleting several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keys">The keys to delete.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.GetAsync(`0,System.Object)">
            <summary>
            Retrieves the value stored for a single key.
            </summary>
            <param name="key">The key to query for.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.GetAsync(System.Collections.Generic.IEnumerable{`0},System.Object)">
            <summary>
            Retrieves the values stored for a set of keys.
            This overload should be used to reduce the cost of querying for several keys from the same store, since it requires only one
            round trip to the Object Store server.
            </summary>
            <param name="keys">The keys to query for.</param>
            <param name="state">An optional object that will be the AsyncState in the returned <see cref="T:System.Threading.Tasks.Task`1"/></param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> that can be used to get results either synchronously (<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or
            asynchronously (<see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})"/>).
            Keys that don't have values are present in the dictionary with a <c>null</c> value.
            </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``1(`0,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Run coproc with a single key
            </summary>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="key">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by coproc and debug information</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``1(`0,System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with a single key
            </summary>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="key">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Unused</param>
            <returns>List of <typeparamref name="TCoprocValue"/> resulted by coproc </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoIndexQueryWithValueAsync(ObjectStoreWireProtocol.IndexQueryRequest)">
            <summary>
            Do index query with value asynchronously.
            </summary>
            <param name="indexQueryRequest">Index query request</param>
            <returns>Query results</returns>
            <exception cref="T:System.Exception">Throw exception when error</exception>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoIndexQueryKeyOnlyAsync(ObjectStoreWireProtocol.IndexQueryRequest)">
            <summary>
            Do index query key only asynchronously.
            </summary>
            <param name="indexQueryRequest">Index query request</param>
            <returns>A list of key results</returns>
            <exception cref="T:System.Exception">Throw exception when error</exception>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoIndexQueryWithValueFullResponseAsync(ObjectStoreWireProtocol.IndexQueryRequest)">
            <summary>
            Do index query with value asynchronously and return response with debugging info.
            </summary>
            <param name="indexQueryRequest">Index query request</param>
            <returns>Index query full response</returns>
            <exception cref="T:System.Exception">Throw exception only when timeout</exception>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoIndexQueryKeyOnlyFullResponseAsync(ObjectStoreWireProtocol.IndexQueryRequest)">
            <summary>
            Do index query key only asynchronously and return response with debugging info.
            </summary>
            <param name="indexQueryRequest">Index query request</param>
            <returns>Index query full response</returns>
            <exception cref="T:System.Exception">Throw exception only when timeout</exception>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``2(`0,System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with a single key
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="key">The KeyData for Coproc operation</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Unused</param>
            <returns>List of <typeparamref name="TCoprocValue"/> resulted by coproc </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``2(`0,System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Run coproc with a single key
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="key">The KeyData for Coproc operation</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by coproc and debug information</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``1(System.Collections.Generic.IEnumerable{`0},System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys
            </summary>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyDatas for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> resulted by coproc </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple key / value pairs
            </summary>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc and debug information for each key/value pair.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple key / value pairs
            </summary>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple key / value pairs.
            Includes TPar parameter
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc and debug information for each key/value pair.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple key / value pairs.
            Includes TPar parameter
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyData for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc.</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``2(System.Collections.Generic.IEnumerable{`0},System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyDatas for Coproc operation</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc and debug information for each key</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``2(System.Collections.Generic.IEnumerable{`0},System.String,``0,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys
            </summary>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keys">The KeyDatas for Coproc operation</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``0}},System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys and key parameters
            </summary>
            <typeparam name="TKeyParam">Parameter type for key parameters to be used by coprocs</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keysWithKeyParams">The KeyDatas and their corresponding parameters for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> resulted by coproc </returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsyncWithDetails``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``0}},System.String,``1,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys and key parameters
            </summary>
            <typeparam name="TKeyParam">Parameter type for key parameters to be used by coprocs</typeparam>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keysWithKeyParams">The KeyDatas and their corresponding parameters for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc and debug information for each key</returns>
        </member>
        <member name="M:Microsoft.Search.ObjectStore.ObjectStoreClient`2.DoQueryAsync``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,``0}},System.String,``1,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Run coproc with multiple keys and key parameters
            </summary>
            <typeparam name="TKeyParam">Parameter type for key parameters to be used by coprocs</typeparam>
            <typeparam name="TPar">Generics type of parameter used by coproc</typeparam>
            <typeparam name="TCoprocValue">Generics type of coproc response data</typeparam>
            <param name="keysWithKeyParams">The KeyDatas and their corresponding parameters for Coproc operation</param>
            <param name="coprocName">Coproc OperationName</param>
            <param name="parameter">The parameter used by coproc operation</param>
            <param name="headers">http headers needs to be passed to Object Store through http request e.g BingIDToken</param>
            <param name="batchSize">Number of elements in each batch to be submitted to Object Store</param>
            <returns>List of <typeparamref name="TCoprocValue"/> emitted by the coproc</returns>
        </member>
    </members>
</doc>
